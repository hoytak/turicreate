// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FeatureTypes.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "FeatureTypes.pb.h"

#include <algorithm>

#include <protobuf/stubs/common.h>
#include <protobuf/stubs/port.h>
#include <protobuf/stubs/once.h>
#include <protobuf/io/coded_stream.h>
#include <protobuf/wire_format_lite_inl.h>
#include <protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {

void protobuf_ShutdownFile_FeatureTypes_2eproto() {
  Int64FeatureType_default_instance_.Shutdown();
  DoubleFeatureType_default_instance_.Shutdown();
  StringFeatureType_default_instance_.Shutdown();
  ImageFeatureType_default_instance_.Shutdown();
  ArrayFeatureType_default_instance_.Shutdown();
  DictionaryFeatureType_default_instance_.Shutdown();
  FeatureType_default_instance_.Shutdown();
}

void protobuf_InitDefaults_FeatureTypes_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  Int64FeatureType_default_instance_.DefaultConstruct();
  DoubleFeatureType_default_instance_.DefaultConstruct();
  StringFeatureType_default_instance_.DefaultConstruct();
  ImageFeatureType_default_instance_.DefaultConstruct();
  ArrayFeatureType_default_instance_.DefaultConstruct();
  DictionaryFeatureType_default_instance_.DefaultConstruct();
  FeatureType_default_instance_.DefaultConstruct();
  Int64FeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
  DoubleFeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
  StringFeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
  ImageFeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
  ArrayFeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
  DictionaryFeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
  FeatureType_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_FeatureTypes_2eproto_once_);
void protobuf_InitDefaults_FeatureTypes_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_FeatureTypes_2eproto_once_,
                 &protobuf_InitDefaults_FeatureTypes_2eproto_impl);
}
void protobuf_AddDesc_FeatureTypes_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_FeatureTypes_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_FeatureTypes_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_FeatureTypes_2eproto_once_);
void protobuf_AddDesc_FeatureTypes_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_FeatureTypes_2eproto_once_,
                 &protobuf_AddDesc_FeatureTypes_2eproto_impl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_FeatureTypes_2eproto {
  StaticDescriptorInitializer_FeatureTypes_2eproto() {
    protobuf_AddDesc_FeatureTypes_2eproto();
  }
} static_descriptor_initializer_FeatureTypes_2eproto_;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64FeatureType::Int64FeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64FeatureType)
}

void Int64FeatureType::InitAsDefaultInstance() {
}

Int64FeatureType::Int64FeatureType(const Int64FeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64FeatureType)
}

void Int64FeatureType::SharedCtor() {
  _cached_size_ = 0;
}

Int64FeatureType::~Int64FeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64FeatureType)
  SharedDtor();
}

void Int64FeatureType::SharedDtor() {
}

void Int64FeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64FeatureType& Int64FeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Int64FeatureType> Int64FeatureType_default_instance_;

Int64FeatureType* Int64FeatureType::New(::google::protobuf::Arena* arena) const {
  Int64FeatureType* n = new Int64FeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64FeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64FeatureType)
}

bool Int64FeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64FeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64FeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64FeatureType)
  return false;
#undef DO_
}

void Int64FeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64FeatureType)
  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64FeatureType)
}

size_t Int64FeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64FeatureType)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64FeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64FeatureType*>(&from));
}

void Int64FeatureType::MergeFrom(const Int64FeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64FeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Int64FeatureType::UnsafeMergeFrom(const Int64FeatureType& from) {
  GOOGLE_DCHECK(&from != this);
}

void Int64FeatureType::CopyFrom(const Int64FeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64FeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Int64FeatureType::IsInitialized() const {

  return true;
}

void Int64FeatureType::Swap(Int64FeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64FeatureType::InternalSwap(Int64FeatureType* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64FeatureType::GetTypeName() const {
  return "CoreML.Specification.Int64FeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64FeatureType

inline const Int64FeatureType* Int64FeatureType::internal_default_instance() {
  return &Int64FeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DoubleFeatureType::DoubleFeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DoubleFeatureType)
}

void DoubleFeatureType::InitAsDefaultInstance() {
}

DoubleFeatureType::DoubleFeatureType(const DoubleFeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleFeatureType)
}

void DoubleFeatureType::SharedCtor() {
  _cached_size_ = 0;
}

DoubleFeatureType::~DoubleFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleFeatureType)
  SharedDtor();
}

void DoubleFeatureType::SharedDtor() {
}

void DoubleFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DoubleFeatureType& DoubleFeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<DoubleFeatureType> DoubleFeatureType_default_instance_;

DoubleFeatureType* DoubleFeatureType::New(::google::protobuf::Arena* arena) const {
  DoubleFeatureType* n = new DoubleFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DoubleFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleFeatureType)
}

bool DoubleFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DoubleFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DoubleFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DoubleFeatureType)
  return false;
#undef DO_
}

void DoubleFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DoubleFeatureType)
  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DoubleFeatureType)
}

size_t DoubleFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleFeatureType)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DoubleFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DoubleFeatureType*>(&from));
}

void DoubleFeatureType::MergeFrom(const DoubleFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleFeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void DoubleFeatureType::UnsafeMergeFrom(const DoubleFeatureType& from) {
  GOOGLE_DCHECK(&from != this);
}

void DoubleFeatureType::CopyFrom(const DoubleFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleFeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool DoubleFeatureType::IsInitialized() const {

  return true;
}

void DoubleFeatureType::Swap(DoubleFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DoubleFeatureType::InternalSwap(DoubleFeatureType* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DoubleFeatureType::GetTypeName() const {
  return "CoreML.Specification.DoubleFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DoubleFeatureType

inline const DoubleFeatureType* DoubleFeatureType::internal_default_instance() {
  return &DoubleFeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringFeatureType::StringFeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringFeatureType)
}

void StringFeatureType::InitAsDefaultInstance() {
}

StringFeatureType::StringFeatureType(const StringFeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringFeatureType)
}

void StringFeatureType::SharedCtor() {
  _cached_size_ = 0;
}

StringFeatureType::~StringFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringFeatureType)
  SharedDtor();
}

void StringFeatureType::SharedDtor() {
}

void StringFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringFeatureType& StringFeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<StringFeatureType> StringFeatureType_default_instance_;

StringFeatureType* StringFeatureType::New(::google::protobuf::Arena* arena) const {
  StringFeatureType* n = new StringFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringFeatureType)
}

bool StringFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringFeatureType)
  return false;
#undef DO_
}

void StringFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringFeatureType)
  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringFeatureType)
}

size_t StringFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringFeatureType)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringFeatureType*>(&from));
}

void StringFeatureType::MergeFrom(const StringFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringFeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void StringFeatureType::UnsafeMergeFrom(const StringFeatureType& from) {
  GOOGLE_DCHECK(&from != this);
}

void StringFeatureType::CopyFrom(const StringFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringFeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool StringFeatureType::IsInitialized() const {

  return true;
}

void StringFeatureType::Swap(StringFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringFeatureType::InternalSwap(StringFeatureType* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringFeatureType::GetTypeName() const {
  return "CoreML.Specification.StringFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringFeatureType

inline const StringFeatureType* StringFeatureType::internal_default_instance() {
  return &StringFeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool ImageFeatureType_ColorSpace_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 20:
    case 30:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ImageFeatureType_ColorSpace ImageFeatureType::INVALID_COLOR_SPACE;
const ImageFeatureType_ColorSpace ImageFeatureType::GRAYSCALE;
const ImageFeatureType_ColorSpace ImageFeatureType::RGB;
const ImageFeatureType_ColorSpace ImageFeatureType::BGR;
const ImageFeatureType_ColorSpace ImageFeatureType::ColorSpace_MIN;
const ImageFeatureType_ColorSpace ImageFeatureType::ColorSpace_MAX;
const int ImageFeatureType::ColorSpace_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageFeatureType::kWidthFieldNumber;
const int ImageFeatureType::kHeightFieldNumber;
const int ImageFeatureType::kColorSpaceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageFeatureType::ImageFeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ImageFeatureType)
}

void ImageFeatureType::InitAsDefaultInstance() {
}

ImageFeatureType::ImageFeatureType(const ImageFeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType)
}

void ImageFeatureType::SharedCtor() {
  ::memset(&width_, 0, reinterpret_cast<char*>(&colorspace_) -
    reinterpret_cast<char*>(&width_) + sizeof(colorspace_));
  _cached_size_ = 0;
}

ImageFeatureType::~ImageFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType)
  SharedDtor();
}

void ImageFeatureType::SharedDtor() {
}

void ImageFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageFeatureType& ImageFeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<ImageFeatureType> ImageFeatureType_default_instance_;

ImageFeatureType* ImageFeatureType::New(::google::protobuf::Arena* arena) const {
  ImageFeatureType* n = new ImageFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ImageFeatureType, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ImageFeatureType*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(width_, colorspace_);

#undef ZR_HELPER_
#undef ZR_

}

bool ImageFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ImageFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 width = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // optional uint64 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_colorSpace;
        break;
      }

      // optional .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
      case 3: {
        if (tag == 24) {
         parse_colorSpace:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_colorspace(static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ImageFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ImageFeatureType)
  return false;
#undef DO_
}

void ImageFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ImageFeatureType)
  // optional uint64 width = 1;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->width(), output);
  }

  // optional uint64 height = 2;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->height(), output);
  }

  // optional .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  if (this->colorspace() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->colorspace(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ImageFeatureType)
}

size_t ImageFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType)
  size_t total_size = 0;

  // optional uint64 width = 1;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->width());
  }

  // optional uint64 height = 2;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->height());
  }

  // optional .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  if (this->colorspace() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->colorspace());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageFeatureType*>(&from));
}

void ImageFeatureType::MergeFrom(const ImageFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void ImageFeatureType::UnsafeMergeFrom(const ImageFeatureType& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.colorspace() != 0) {
    set_colorspace(from.colorspace());
  }
}

void ImageFeatureType::CopyFrom(const ImageFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool ImageFeatureType::IsInitialized() const {

  return true;
}

void ImageFeatureType::Swap(ImageFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageFeatureType::InternalSwap(ImageFeatureType* other) {
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(colorspace_, other->colorspace_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ImageFeatureType::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageFeatureType

// optional uint64 width = 1;
void ImageFeatureType::clear_width() {
  width_ = GOOGLE_ULONGLONG(0);
}
::google::protobuf::uint64 ImageFeatureType::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.width)
  return width_;
}
void ImageFeatureType::set_width(::google::protobuf::uint64 value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.width)
}

// optional uint64 height = 2;
void ImageFeatureType::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
::google::protobuf::uint64 ImageFeatureType::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.height)
  return height_;
}
void ImageFeatureType::set_height(::google::protobuf::uint64 value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.height)
}

// optional .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
void ImageFeatureType::clear_colorspace() {
  colorspace_ = 0;
}
::CoreML::Specification::ImageFeatureType_ColorSpace ImageFeatureType::colorspace() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.colorSpace)
  return static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(colorspace_);
}
void ImageFeatureType::set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value) {

  colorspace_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.colorSpace)
}

inline const ImageFeatureType* ImageFeatureType::internal_default_instance() {
  return &ImageFeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool ArrayFeatureType_ArrayDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 65568:
    case 65600:
    case 131104:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ArrayFeatureType_ArrayDataType ArrayFeatureType::INVALID_ARRAY_DATA_TYPE;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::FLOAT32;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::DOUBLE;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::INT32;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::ArrayDataType_MIN;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::ArrayDataType_MAX;
const int ArrayFeatureType::ArrayDataType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ArrayFeatureType::kShapeFieldNumber;
const int ArrayFeatureType::kDataTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ArrayFeatureType::ArrayFeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ArrayFeatureType)
}

void ArrayFeatureType::InitAsDefaultInstance() {
}

ArrayFeatureType::ArrayFeatureType(const ArrayFeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType)
}

void ArrayFeatureType::SharedCtor() {
  datatype_ = 0;
  _cached_size_ = 0;
}

ArrayFeatureType::~ArrayFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType)
  SharedDtor();
}

void ArrayFeatureType::SharedDtor() {
}

void ArrayFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ArrayFeatureType& ArrayFeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<ArrayFeatureType> ArrayFeatureType_default_instance_;

ArrayFeatureType* ArrayFeatureType::New(::google::protobuf::Arena* arena) const {
  ArrayFeatureType* n = new ArrayFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ArrayFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType)
  datatype_ = 0;
  shape_.Clear();
}

bool ArrayFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ArrayFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint64 shape = 1;
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_shape())));
        } else if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 10, input, this->mutable_shape())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_dataType;
        break;
      }

      // optional .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
      case 2: {
        if (tag == 16) {
         parse_dataType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_datatype(static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ArrayFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ArrayFeatureType)
  return false;
#undef DO_
}

void ArrayFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ArrayFeatureType)
  // repeated uint64 shape = 1;
  if (this->shape_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_shape_cached_byte_size_);
  }
  for (int i = 0; i < this->shape_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64NoTag(
      this->shape(i), output);
  }

  // optional .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  if (this->datatype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->datatype(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ArrayFeatureType)
}

size_t ArrayFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType)
  size_t total_size = 0;

  // optional .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  if (this->datatype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->datatype());
  }

  // repeated uint64 shape = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->shape_size();
    for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->shape(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _shape_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArrayFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ArrayFeatureType*>(&from));
}

void ArrayFeatureType::MergeFrom(const ArrayFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void ArrayFeatureType::UnsafeMergeFrom(const ArrayFeatureType& from) {
  GOOGLE_DCHECK(&from != this);
  shape_.UnsafeMergeFrom(from.shape_);
  if (from.datatype() != 0) {
    set_datatype(from.datatype());
  }
}

void ArrayFeatureType::CopyFrom(const ArrayFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool ArrayFeatureType::IsInitialized() const {

  return true;
}

void ArrayFeatureType::Swap(ArrayFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ArrayFeatureType::InternalSwap(ArrayFeatureType* other) {
  shape_.UnsafeArenaSwap(&other->shape_);
  std::swap(datatype_, other->datatype_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ArrayFeatureType::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ArrayFeatureType

// repeated uint64 shape = 1;
int ArrayFeatureType::shape_size() const {
  return shape_.size();
}
void ArrayFeatureType::clear_shape() {
  shape_.Clear();
}
::google::protobuf::uint64 ArrayFeatureType::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shape)
  return shape_.Get(index);
}
void ArrayFeatureType::set_shape(int index, ::google::protobuf::uint64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.shape)
}
void ArrayFeatureType::add_shape(::google::protobuf::uint64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.shape)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ArrayFeatureType::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.shape)
  return shape_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ArrayFeatureType::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.shape)
  return &shape_;
}

// optional .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
void ArrayFeatureType::clear_datatype() {
  datatype_ = 0;
}
::CoreML::Specification::ArrayFeatureType_ArrayDataType ArrayFeatureType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.dataType)
  return static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(datatype_);
}
void ArrayFeatureType::set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value) {

  datatype_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.dataType)
}

inline const ArrayFeatureType* ArrayFeatureType::internal_default_instance() {
  return &ArrayFeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DictionaryFeatureType::kInt64KeyTypeFieldNumber;
const int DictionaryFeatureType::kStringKeyTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DictionaryFeatureType::DictionaryFeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DictionaryFeatureType)
}

void DictionaryFeatureType::InitAsDefaultInstance() {
}

DictionaryFeatureType::DictionaryFeatureType(const DictionaryFeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DictionaryFeatureType)
}

void DictionaryFeatureType::SharedCtor() {
  clear_has_KeyType();
  _cached_size_ = 0;
}

DictionaryFeatureType::~DictionaryFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DictionaryFeatureType)
  SharedDtor();
}

void DictionaryFeatureType::SharedDtor() {
  if (has_KeyType()) {
    clear_KeyType();
  }
}

void DictionaryFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DictionaryFeatureType& DictionaryFeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<DictionaryFeatureType> DictionaryFeatureType_default_instance_;

DictionaryFeatureType* DictionaryFeatureType::New(::google::protobuf::Arena* arena) const {
  DictionaryFeatureType* n = new DictionaryFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DictionaryFeatureType::clear_KeyType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.DictionaryFeatureType)
  switch (KeyType_case()) {
    case kInt64KeyType: {
      delete KeyType_.int64keytype_;
      break;
    }
    case kStringKeyType: {
      delete KeyType_.stringkeytype_;
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}


void DictionaryFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DictionaryFeatureType)
  clear_KeyType();
}

bool DictionaryFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DictionaryFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CoreML.Specification.Int64FeatureType int64KeyType = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64keytype()));
        } else {
          goto handle_unusual;
        }
        goto after_stringkeytype;
        break;
      }

      // optional .CoreML.Specification.StringFeatureType stringKeyType = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringkeytype()));
        } else {
          goto handle_unusual;
        }
       after_stringkeytype:
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DictionaryFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DictionaryFeatureType)
  return false;
#undef DO_
}

void DictionaryFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DictionaryFeatureType)
  // optional .CoreML.Specification.Int64FeatureType int64KeyType = 1;
  if (has_int64keytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *KeyType_.int64keytype_, output);
  }

  // optional .CoreML.Specification.StringFeatureType stringKeyType = 2;
  if (has_stringkeytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *KeyType_.stringkeytype_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DictionaryFeatureType)
}

size_t DictionaryFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DictionaryFeatureType)
  size_t total_size = 0;

  switch (KeyType_case()) {
    // optional .CoreML.Specification.Int64FeatureType int64KeyType = 1;
    case kInt64KeyType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *KeyType_.int64keytype_);
      break;
    }
    // optional .CoreML.Specification.StringFeatureType stringKeyType = 2;
    case kStringKeyType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *KeyType_.stringkeytype_);
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DictionaryFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DictionaryFeatureType*>(&from));
}

void DictionaryFeatureType::MergeFrom(const DictionaryFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DictionaryFeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void DictionaryFeatureType::UnsafeMergeFrom(const DictionaryFeatureType& from) {
  GOOGLE_DCHECK(&from != this);
  switch (from.KeyType_case()) {
    case kInt64KeyType: {
      mutable_int64keytype()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64keytype());
      break;
    }
    case kStringKeyType: {
      mutable_stringkeytype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringkeytype());
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
}

void DictionaryFeatureType::CopyFrom(const DictionaryFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DictionaryFeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool DictionaryFeatureType::IsInitialized() const {

  return true;
}

void DictionaryFeatureType::Swap(DictionaryFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DictionaryFeatureType::InternalSwap(DictionaryFeatureType* other) {
  std::swap(KeyType_, other->KeyType_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DictionaryFeatureType::GetTypeName() const {
  return "CoreML.Specification.DictionaryFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DictionaryFeatureType

// optional .CoreML.Specification.Int64FeatureType int64KeyType = 1;
bool DictionaryFeatureType::has_int64keytype() const {
  return KeyType_case() == kInt64KeyType;
}
void DictionaryFeatureType::set_has_int64keytype() {
  _oneof_case_[0] = kInt64KeyType;
}
void DictionaryFeatureType::clear_int64keytype() {
  if (has_int64keytype()) {
    delete KeyType_.int64keytype_;
    clear_has_KeyType();
  }
}
 const ::CoreML::Specification::Int64FeatureType& DictionaryFeatureType::int64keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return has_int64keytype()
      ? *KeyType_.int64keytype_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::mutable_int64keytype() {
  if (!has_int64keytype()) {
    clear_KeyType();
    set_has_int64keytype();
    KeyType_.int64keytype_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return KeyType_.int64keytype_;
}
::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::release_int64keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  if (has_int64keytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::Int64FeatureType* temp = KeyType_.int64keytype_;
    KeyType_.int64keytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void DictionaryFeatureType::set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype) {
  clear_KeyType();
  if (int64keytype) {
    set_has_int64keytype();
    KeyType_.int64keytype_ = int64keytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.int64KeyType)
}

// optional .CoreML.Specification.StringFeatureType stringKeyType = 2;
bool DictionaryFeatureType::has_stringkeytype() const {
  return KeyType_case() == kStringKeyType;
}
void DictionaryFeatureType::set_has_stringkeytype() {
  _oneof_case_[0] = kStringKeyType;
}
void DictionaryFeatureType::clear_stringkeytype() {
  if (has_stringkeytype()) {
    delete KeyType_.stringkeytype_;
    clear_has_KeyType();
  }
}
 const ::CoreML::Specification::StringFeatureType& DictionaryFeatureType::stringkeytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return has_stringkeytype()
      ? *KeyType_.stringkeytype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
::CoreML::Specification::StringFeatureType* DictionaryFeatureType::mutable_stringkeytype() {
  if (!has_stringkeytype()) {
    clear_KeyType();
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return KeyType_.stringkeytype_;
}
::CoreML::Specification::StringFeatureType* DictionaryFeatureType::release_stringkeytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  if (has_stringkeytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::StringFeatureType* temp = KeyType_.stringkeytype_;
    KeyType_.stringkeytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void DictionaryFeatureType::set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype) {
  clear_KeyType();
  if (stringkeytype) {
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = stringkeytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.stringKeyType)
}

bool DictionaryFeatureType::has_KeyType() const {
  return KeyType_case() != KEYTYPE_NOT_SET;
}
void DictionaryFeatureType::clear_has_KeyType() {
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}
DictionaryFeatureType::KeyTypeCase DictionaryFeatureType::KeyType_case() const {
  return DictionaryFeatureType::KeyTypeCase(_oneof_case_[0]);
}
inline const DictionaryFeatureType* DictionaryFeatureType::internal_default_instance() {
  return &DictionaryFeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FeatureType::kInt64TypeFieldNumber;
const int FeatureType::kDoubleTypeFieldNumber;
const int FeatureType::kStringTypeFieldNumber;
const int FeatureType::kImageTypeFieldNumber;
const int FeatureType::kMultiArrayTypeFieldNumber;
const int FeatureType::kDictionaryTypeFieldNumber;
const int FeatureType::kIsOptionalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FeatureType::FeatureType()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_FeatureTypes_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.FeatureType)
}

void FeatureType::InitAsDefaultInstance() {
}

FeatureType::FeatureType(const FeatureType& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FeatureType)
}

void FeatureType::SharedCtor() {
  isoptional_ = false;
  clear_has_Type();
  _cached_size_ = 0;
}

FeatureType::~FeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FeatureType)
  SharedDtor();
}

void FeatureType::SharedDtor() {
  if (has_Type()) {
    clear_Type();
  }
}

void FeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FeatureType& FeatureType::default_instance() {
  protobuf_InitDefaults_FeatureTypes_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<FeatureType> FeatureType_default_instance_;

FeatureType* FeatureType::New(::google::protobuf::Arena* arena) const {
  FeatureType* n = new FeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FeatureType::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.FeatureType)
  switch (Type_case()) {
    case kInt64Type: {
      delete Type_.int64type_;
      break;
    }
    case kDoubleType: {
      delete Type_.doubletype_;
      break;
    }
    case kStringType: {
      delete Type_.stringtype_;
      break;
    }
    case kImageType: {
      delete Type_.imagetype_;
      break;
    }
    case kMultiArrayType: {
      delete Type_.multiarraytype_;
      break;
    }
    case kDictionaryType: {
      delete Type_.dictionarytype_;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void FeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FeatureType)
  isoptional_ = false;
  clear_Type();
}

bool FeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.FeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CoreML.Specification.Int64FeatureType int64Type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64type()));
        } else {
          goto handle_unusual;
        }
        goto after_dictionarytype;
        break;
      }

      // optional .CoreML.Specification.DoubleFeatureType doubleType = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_doubletype()));
        } else {
          goto handle_unusual;
        }
        goto after_dictionarytype;
        break;
      }

      // optional .CoreML.Specification.StringFeatureType stringType = 3;
      case 3: {
        if (tag == 26) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringtype()));
        } else {
          goto handle_unusual;
        }
        goto after_dictionarytype;
        break;
      }

      // optional .CoreML.Specification.ImageFeatureType imageType = 4;
      case 4: {
        if (tag == 34) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imagetype()));
        } else {
          goto handle_unusual;
        }
        goto after_dictionarytype;
        break;
      }

      // optional .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
      case 5: {
        if (tag == 42) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multiarraytype()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_dictionaryType;
        break;
      }

      // optional .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
      case 6: {
        if (tag == 50) {
         parse_dictionaryType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dictionarytype()));
        } else {
          goto handle_unusual;
        }
       after_dictionarytype:
        if (input->ExpectTag(8000)) goto parse_isOptional;
        break;
      }

      // optional bool isOptional = 1000;
      case 1000: {
        if (tag == 8000) {
         parse_isOptional:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isoptional_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.FeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.FeatureType)
  return false;
#undef DO_
}

void FeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.FeatureType)
  // optional .CoreML.Specification.Int64FeatureType int64Type = 1;
  if (has_int64type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *Type_.int64type_, output);
  }

  // optional .CoreML.Specification.DoubleFeatureType doubleType = 2;
  if (has_doubletype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *Type_.doubletype_, output);
  }

  // optional .CoreML.Specification.StringFeatureType stringType = 3;
  if (has_stringtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *Type_.stringtype_, output);
  }

  // optional .CoreML.Specification.ImageFeatureType imageType = 4;
  if (has_imagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *Type_.imagetype_, output);
  }

  // optional .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
  if (has_multiarraytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *Type_.multiarraytype_, output);
  }

  // optional .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
  if (has_dictionarytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *Type_.dictionarytype_, output);
  }

  // optional bool isOptional = 1000;
  if (this->isoptional() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1000, this->isoptional(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.FeatureType)
}

size_t FeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FeatureType)
  size_t total_size = 0;

  // optional bool isOptional = 1000;
  if (this->isoptional() != 0) {
    total_size += 2 + 1;
  }

  switch (Type_case()) {
    // optional .CoreML.Specification.Int64FeatureType int64Type = 1;
    case kInt64Type: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.int64type_);
      break;
    }
    // optional .CoreML.Specification.DoubleFeatureType doubleType = 2;
    case kDoubleType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.doubletype_);
      break;
    }
    // optional .CoreML.Specification.StringFeatureType stringType = 3;
    case kStringType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.stringtype_);
      break;
    }
    // optional .CoreML.Specification.ImageFeatureType imageType = 4;
    case kImageType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.imagetype_);
      break;
    }
    // optional .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
    case kMultiArrayType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.multiarraytype_);
      break;
    }
    // optional .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
    case kDictionaryType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.dictionarytype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FeatureType*>(&from));
}

void FeatureType::MergeFrom(const FeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FeatureType)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void FeatureType::UnsafeMergeFrom(const FeatureType& from) {
  GOOGLE_DCHECK(&from != this);
  switch (from.Type_case()) {
    case kInt64Type: {
      mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64type());
      break;
    }
    case kDoubleType: {
      mutable_doubletype()->::CoreML::Specification::DoubleFeatureType::MergeFrom(from.doubletype());
      break;
    }
    case kStringType: {
      mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringtype());
      break;
    }
    case kImageType: {
      mutable_imagetype()->::CoreML::Specification::ImageFeatureType::MergeFrom(from.imagetype());
      break;
    }
    case kMultiArrayType: {
      mutable_multiarraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from.multiarraytype());
      break;
    }
    case kDictionaryType: {
      mutable_dictionarytype()->::CoreML::Specification::DictionaryFeatureType::MergeFrom(from.dictionarytype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (from.isoptional() != 0) {
    set_isoptional(from.isoptional());
  }
}

void FeatureType::CopyFrom(const FeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FeatureType)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool FeatureType::IsInitialized() const {

  return true;
}

void FeatureType::Swap(FeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FeatureType::InternalSwap(FeatureType* other) {
  std::swap(isoptional_, other->isoptional_);
  std::swap(Type_, other->Type_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FeatureType::GetTypeName() const {
  return "CoreML.Specification.FeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FeatureType

// optional .CoreML.Specification.Int64FeatureType int64Type = 1;
bool FeatureType::has_int64type() const {
  return Type_case() == kInt64Type;
}
void FeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
void FeatureType::clear_int64type() {
  if (has_int64type()) {
    delete Type_.int64type_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Int64FeatureType& FeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.int64Type)
  return has_int64type()
      ? *Type_.int64type_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
::CoreML::Specification::Int64FeatureType* FeatureType::mutable_int64type() {
  if (!has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.int64Type)
  return Type_.int64type_;
}
::CoreML::Specification::Int64FeatureType* FeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.int64Type)
  if (has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.int64Type)
}

// optional .CoreML.Specification.DoubleFeatureType doubleType = 2;
bool FeatureType::has_doubletype() const {
  return Type_case() == kDoubleType;
}
void FeatureType::set_has_doubletype() {
  _oneof_case_[0] = kDoubleType;
}
void FeatureType::clear_doubletype() {
  if (has_doubletype()) {
    delete Type_.doubletype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::DoubleFeatureType& FeatureType::doubletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.doubleType)
  return has_doubletype()
      ? *Type_.doubletype_
      : ::CoreML::Specification::DoubleFeatureType::default_instance();
}
::CoreML::Specification::DoubleFeatureType* FeatureType::mutable_doubletype() {
  if (!has_doubletype()) {
    clear_Type();
    set_has_doubletype();
    Type_.doubletype_ = new ::CoreML::Specification::DoubleFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.doubleType)
  return Type_.doubletype_;
}
::CoreML::Specification::DoubleFeatureType* FeatureType::release_doubletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.doubleType)
  if (has_doubletype()) {
    clear_has_Type();
    ::CoreML::Specification::DoubleFeatureType* temp = Type_.doubletype_;
    Type_.doubletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype) {
  clear_Type();
  if (doubletype) {
    set_has_doubletype();
    Type_.doubletype_ = doubletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.doubleType)
}

// optional .CoreML.Specification.StringFeatureType stringType = 3;
bool FeatureType::has_stringtype() const {
  return Type_case() == kStringType;
}
void FeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
void FeatureType::clear_stringtype() {
  if (has_stringtype()) {
    delete Type_.stringtype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::StringFeatureType& FeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.stringType)
  return has_stringtype()
      ? *Type_.stringtype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
::CoreML::Specification::StringFeatureType* FeatureType::mutable_stringtype() {
  if (!has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.stringType)
  return Type_.stringtype_;
}
::CoreML::Specification::StringFeatureType* FeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.stringType)
  if (has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.stringType)
}

// optional .CoreML.Specification.ImageFeatureType imageType = 4;
bool FeatureType::has_imagetype() const {
  return Type_case() == kImageType;
}
void FeatureType::set_has_imagetype() {
  _oneof_case_[0] = kImageType;
}
void FeatureType::clear_imagetype() {
  if (has_imagetype()) {
    delete Type_.imagetype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::ImageFeatureType& FeatureType::imagetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.imageType)
  return has_imagetype()
      ? *Type_.imagetype_
      : ::CoreML::Specification::ImageFeatureType::default_instance();
}
::CoreML::Specification::ImageFeatureType* FeatureType::mutable_imagetype() {
  if (!has_imagetype()) {
    clear_Type();
    set_has_imagetype();
    Type_.imagetype_ = new ::CoreML::Specification::ImageFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.imageType)
  return Type_.imagetype_;
}
::CoreML::Specification::ImageFeatureType* FeatureType::release_imagetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.imageType)
  if (has_imagetype()) {
    clear_has_Type();
    ::CoreML::Specification::ImageFeatureType* temp = Type_.imagetype_;
    Type_.imagetype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype) {
  clear_Type();
  if (imagetype) {
    set_has_imagetype();
    Type_.imagetype_ = imagetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.imageType)
}

// optional .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
bool FeatureType::has_multiarraytype() const {
  return Type_case() == kMultiArrayType;
}
void FeatureType::set_has_multiarraytype() {
  _oneof_case_[0] = kMultiArrayType;
}
void FeatureType::clear_multiarraytype() {
  if (has_multiarraytype()) {
    delete Type_.multiarraytype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::ArrayFeatureType& FeatureType::multiarraytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.multiArrayType)
  return has_multiarraytype()
      ? *Type_.multiarraytype_
      : ::CoreML::Specification::ArrayFeatureType::default_instance();
}
::CoreML::Specification::ArrayFeatureType* FeatureType::mutable_multiarraytype() {
  if (!has_multiarraytype()) {
    clear_Type();
    set_has_multiarraytype();
    Type_.multiarraytype_ = new ::CoreML::Specification::ArrayFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.multiArrayType)
  return Type_.multiarraytype_;
}
::CoreML::Specification::ArrayFeatureType* FeatureType::release_multiarraytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.multiArrayType)
  if (has_multiarraytype()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureType* temp = Type_.multiarraytype_;
    Type_.multiarraytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype) {
  clear_Type();
  if (multiarraytype) {
    set_has_multiarraytype();
    Type_.multiarraytype_ = multiarraytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.multiArrayType)
}

// optional .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
bool FeatureType::has_dictionarytype() const {
  return Type_case() == kDictionaryType;
}
void FeatureType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
void FeatureType::clear_dictionarytype() {
  if (has_dictionarytype()) {
    delete Type_.dictionarytype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::DictionaryFeatureType& FeatureType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.dictionaryType)
  return has_dictionarytype()
      ? *Type_.dictionarytype_
      : ::CoreML::Specification::DictionaryFeatureType::default_instance();
}
::CoreML::Specification::DictionaryFeatureType* FeatureType::mutable_dictionarytype() {
  if (!has_dictionarytype()) {
    clear_Type();
    set_has_dictionarytype();
    Type_.dictionarytype_ = new ::CoreML::Specification::DictionaryFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.dictionaryType)
  return Type_.dictionarytype_;
}
::CoreML::Specification::DictionaryFeatureType* FeatureType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.dictionaryType)
  if (has_dictionarytype()) {
    clear_has_Type();
    ::CoreML::Specification::DictionaryFeatureType* temp = Type_.dictionarytype_;
    Type_.dictionarytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype) {
  clear_Type();
  if (dictionarytype) {
    set_has_dictionarytype();
    Type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.dictionaryType)
}

// optional bool isOptional = 1000;
void FeatureType::clear_isoptional() {
  isoptional_ = false;
}
bool FeatureType::isoptional() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.isOptional)
  return isoptional_;
}
void FeatureType::set_isoptional(bool value) {

  isoptional_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureType.isOptional)
}

bool FeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
void FeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
FeatureType::TypeCase FeatureType::Type_case() const {
  return FeatureType::TypeCase(_oneof_case_[0]);
}
inline const FeatureType* FeatureType::internal_default_instance() {
  return &FeatureType_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
